'use client';
import _extends from "@babel/runtime/helpers/esm/extends";
import { useRef, useCallback } from 'react';
import omit from 'lodash/omit';
import set from 'lodash/set';
import { useControlled, useEventCallback } from "../../internals/hooks/index.js";
import { nameToPath } from "../../FormControl/utils.js";
export default function useFormValidate(formError, props) {
  var formValue = props.formValue,
    getCombinedModel = props.getCombinedModel,
    onCheck = props.onCheck,
    onError = props.onError,
    nestedField = props.nestedField;
  var _useControlled = useControlled(formError, {}),
    realFormError = _useControlled[0],
    setFormError = _useControlled[1];
  var realFormErrorRef = useRef(realFormError);
  realFormErrorRef.current = realFormError;

  /**
   * Validate the form data and return a boolean.
   * The error message after verification is returned in the callback.
   * @param callback
   */
  var check = useEventCallback(function (callback) {
    var formError = {};
    var errorCount = 0;
    var model = getCombinedModel();
    Object.keys(model.getSchemaSpec()).forEach(function (key) {
      var checkResult = model.checkForField(key, formValue || {});
      if (checkResult.hasError === true) {
        errorCount += 1;
        formError[key] = (checkResult === null || checkResult === void 0 ? void 0 : checkResult.errorMessage) || checkResult;
      }
    });
    setFormError(formError);
    onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);
    callback === null || callback === void 0 ? void 0 : callback(formError);
    if (errorCount > 0) {
      onError === null || onError === void 0 ? void 0 : onError(formError);
      return false;
    }
    return true;
  });

  /**
   * Check the data field
   * @param fieldName
   * @param callback
   */
  var checkForField = useEventCallback(function (fieldName, callback) {
    var _extends2;
    var model = getCombinedModel();
    var checkResult = model.checkForField(fieldName, formValue || {});
    var nextFormError = _extends({}, formError, (_extends2 = {}, _extends2[fieldName] = (checkResult === null || checkResult === void 0 ? void 0 : checkResult.errorMessage) || checkResult, _extends2));
    setFormError(nextFormError);
    onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);
    callback === null || callback === void 0 ? void 0 : callback(checkResult);
    if (checkResult.hasError) {
      onError === null || onError === void 0 ? void 0 : onError(nextFormError);
    }
    return !checkResult.hasError;
  });

  /**
   * Check form data asynchronously and return a Promise
   */
  var checkAsync = useEventCallback(function () {
    var promises = [];
    var keys = [];
    var model = getCombinedModel();
    Object.keys(model.getSchemaSpec()).forEach(function (key) {
      keys.push(key);
      promises.push(model.checkForFieldAsync(key, formValue || {}));
    });
    return Promise.all(promises).then(function (values) {
      var formError = {};
      var errorCount = 0;
      for (var i = 0; i < values.length; i++) {
        if (values[i].hasError) {
          errorCount += 1;
          formError[keys[i]] = values[i].errorMessage;
        }
      }
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);
      setFormError(formError);
      if (errorCount > 0) {
        onError === null || onError === void 0 ? void 0 : onError(formError);
      }
      return {
        hasError: errorCount > 0,
        formError: formError
      };
    });
  });

  /**
   * Asynchronously check form fields and return Promise
   * @param fieldName
   */
  var checkForFieldAsync = useEventCallback(function (fieldName) {
    var model = getCombinedModel();
    return model.checkForFieldAsync(fieldName, formValue || {}).then(function (checkResult) {
      var _extends3;
      var nextFormError = _extends({}, formError, (_extends3 = {}, _extends3[fieldName] = checkResult.errorMessage, _extends3));
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);
      setFormError(nextFormError);
      if (checkResult.hasError) {
        onError === null || onError === void 0 ? void 0 : onError(nextFormError);
      }
      return checkResult;
    });
  });
  var onRemoveError = useCallback(function (name) {
    /**
     * when this function is called when the children component is unmount,
     * it's an old render frame so use Ref to get future error
     */
    var formError = omit(realFormErrorRef.current, [nestedField ? nameToPath(name) : name]);
    realFormErrorRef.current = formError;
    setFormError(formError);
    onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError);
    return formError;
  }, [nestedField, onCheck, setFormError]);
  var setFieldError = useCallback(function (fieldName, checkResult) {
    var _extends4;
    var nextFormError = nestedField ? set(_extends({}, formError), nameToPath(fieldName), checkResult) : _extends({}, formError, (_extends4 = {}, _extends4[fieldName] = checkResult, _extends4));
    setFormError(nextFormError);
    onError === null || onError === void 0 ? void 0 : onError(nextFormError);
    onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);
    return nextFormError;
  }, [formError, nestedField, onCheck, onError, setFormError]);
  var cleanErrors = useEventCallback(function () {
    setFormError({});
  });
  var resetErrors = useEventCallback(function (formError) {
    if (formError === void 0) {
      formError = {};
    }
    setFormError(formError);
  });
  var cleanErrorForField = useEventCallback(function (fieldName) {
    setFormError(omit(formError, [nestedField ? nameToPath(fieldName) : fieldName]));
  });
  return {
    formError: realFormError,
    check: check,
    checkForField: checkForField,
    checkAsync: checkAsync,
    checkForFieldAsync: checkForFieldAsync,
    cleanErrors: cleanErrors,
    resetErrors: resetErrors,
    cleanErrorForField: cleanErrorForField,
    setFieldError: setFieldError,
    onRemoveError: onRemoveError
  };
}